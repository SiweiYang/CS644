\documentclass[12pt,letterpaper]{article}
\usepackage[margin=0.75in]{geometry}
\usepackage[pdftex]{graphicx}
\usepackage[parfill]{parskip}
\usepackage{listings}
\usepackage{color}
\lstset{language=Haskell, frame=single, breaklines=true, keywordstyle=\color{blue}, identifierstyle=\color{red}, basicstyle=\small}

% Submit to Marmoset a PDF document of no more than five pages explaining the design of this phase of your compiler.
% The document should be organized to enable someone unfamiliar with your code to understand the structure of (this phase of) your compiler.
% In the document, discuss challenges that you encountered and how you tried to overcome them in your design and implementation.
% Also explain the testing that you did before submitting to Marmoset.

\begin{document}

\begin{titlepage}
\begin{center}

% Title
\Large \textbf { {\bf CS644 Project} \\ Report: A4}\\[0.5in]

       \small \emph{Submitted in partial fulfillment of\\
        the requirements for the course}
        \vspace{.2in}

% Submitted by
\normalsize Submitted by \\
\begin{table}[h]
\centering
\begin{tabular}{lr}\hline \\
Name & ID\\ \\ \hline
\\
Siwei Yang & s8yang \\ \\ \hline
\\
Justin Vanderheide & jtvander \\ \\ \hline
\\
Jian Li & j493li \\ \\ \hline
\end{tabular}
\end{table}

\vfill

% Bottom of the page
\includegraphics[width=0.3\textwidth]{../res/UWLogo}\\[1.1in]
\Large{Department of Computer Science}\\
\normalsize
\textsc{University of Waterloo}\\
Waterloo, Ontario, Canada -- N2L 3G1 \\
\vspace{0.2cm}
Winter 2015

\end{center}
\end{titlepage}

\section{General Strategy}
%siwei
This section describes the meta strategy we applied in developing solutions to each of the deliveribles. In principle, we are using the attribute grammar approach to finish all the tasks: name resolution, type linking and static analysis.

However, it takes more than merely coding the attribute rules to solve the problem. Auxiliary information might be needed at every node to make the right decision. And the information flows both ways which is hard to support is a pure functional language like Haskell. Besides, we would like to achieve a nice separation between the supporting data structures and the grammar structures.

Therefore, we modelled our solution as three parts: a transformed data structure captures the essense of the AST as well as supporting bi-directional information flow, a newly build data structure that answers queries from the attribute rules and the implementations of the attribute grammars.

\subsection{Engineering a Pure Functional Double-linked AST}
Our first major work is to re-structure the AST so that all the relevant information remains, yet easily accessible while processing each node. This is trivial in language supports mutation where adding a reverse pointer to each AST node solves the problem. However, we are working with a pure functional language. Adding reverse pointer is not viable as explicit pointer is not provided in the langauge. Therefore, we introduced a two layer structure of \emph{SemanticUnit} and \emph{Environment}.
\begin{lstlisting}
data SemanticUnit = Root {
    scope :: [String]
}                               | SU {
    scope :: [String],
    kind :: Kind,
    symbolTable :: [Symbol],
    inheritFrom :: SemanticUnit
} deriving (Eq)

data Environment = ENVE | ENV {
    semantic :: SemanticUnit,
    children :: [Environment]
} deriving (Eq)
\end{lstlisting}

We traverse the AST from top to bottom, meanwhile we build environment using the information in AST nodes.
The structure of the environment is basically a recursive tree.
For each of tree node, it has a \emph{SemanticUnit} which capsules scope info, AST, symbol table and the parent pointer.
The configuration of symbol table is a linked list(or a list) corresponding to the path from the current tree node to the root, and every element in the symbol table is a structure \emph{Symbol}.
The \emph{Symbol} can represent either Package, Class, Interface, Function or Variable, and include all AST information we need.

\emph{Environment} is a recursive data structure that goes top-down, so that down-stream information is naturally available. To get the up-stream information, we follow the \emph{SemanticUnit} all the way to the desired ancestors.

\subsection{Consolidating Type Hierarchy into a Database}
\begin{lstlisting}
data TypeNode = TN {
    symbol :: Symbol,
    subNodes :: [TypeNode]
} deriving (Eq)
\end{lstlisting}

\begin{lstlisting}
traverseTypeEntryWithImports :: TypeNode -> [[String]] -> [String] -> [[String]]
traverseTypeEntryWithImports tn imps query = nub [cname | (Just node, cname) <- results]
    where
        entries = map (traverseTypeEntry tn) imps
        entries' = map (\(mnode, imp) -> (fromJust mnode, imp)) (filter (isJust . fst) (zip entries imps))
        results = map (\(node, imp) -> (traverseTypeEntry node query, (init imp) ++ query)) ((tn, ["*"]):entries')
\end{lstlisting}

\begin{lstlisting}
traverseInstanceEntry' :: TypeNode -> TypeNode -> [String] -> [TypeNode]
traverseInstanceEntry' root tn@(TN (SYM _ _ _ _) _) [] = [tn]
traverseInstanceEntry' root tn@(TN (FUNC _ _ _ _ _) _) [] = [tn]
traverseInstanceEntry' root tn [] = []
traverseInstanceEntry' root (TN (SYM mds ls ln lt) _) (nm:cname) = traverseInstanceEntry' root root ((typeToName lt) ++ (nm:cname))
traverseInstanceEntry' root cur (nm:cname) = case [node | node <- subNodes cur, (localName . symbol) node == nm, (not $ isSYMFUNCNode node) || (not $ elem "static" ((symbolModifiers . symbol) node))] of
                                        []            -> []
                                        targets      -> concat $ map (\target -> traverseInstanceEntry' root target cname) targets
\end{lstlisting}

\subsection{Coding Attribute Rules}



\section{Name Resolution and Type Linking}
%jian
\subsection{Type Linking}

Before we move on to this stage, we already got the symbol table and type database which can be used for looking up local variables and classes(interfaces as well) respectively.
However, the Joos language supports both single-type-import and import-on-demand.
So we can directly use the names of classes which are not in the same package.
This feature would cause lots of troubles during name resolution.
Our solution is first looking up the name from symbol table, if we can find a binding for this name, we return the type declared for this variable.
Otherwise, it is not in the symbol table, then we look up our type database to check whether it is a name of class or interface.
If we cannot find in the type database either, then we claim that we cannot resolve this name.

%\subsection{Reconstructing Environments with canonical names}


\subsection{Type Checking}

The assignment 2 only needs to do type linking which is a part of name resolution. However, when we were doing that part, we already got entire environment and type database.
So we could evaluate the type of each expression and return a list of possible types for that expression.
This is a recursive process since the type attribute of expression are synthesized.
Each time, we pass the current node environment to children, evaluate the types of subexpressions(children), and then combine all types of subexpressions with the format of current expression to get the type of this expression. 
If the return of an expression is an empty list, then we know there exists an error when we evaluated a subexpression or this expression, then just pass this empty list to the upper caller, i.e. propagating the error info to the root.
Or if the return has multiple types, there must exist some ambiguous name, in this case, we also need to report such error.

\subsection{Type Conversion}

Another issue need to deal with is type conversion.
We have to relax some strict type equality checking to a more complicated casting type system defined by conversion rules, since Joos language supports explicit type casting and implicit type conversion in some kinds of expressions.
This part is mainly implemented in the file \emph{TypeChecking.hs}.
According to JLS, there are many kinds of conversions for primitive types and references types.
And the conversions used in assignment(operator \{=\}) and casting are also slightly different.
Besides, for the binary operators \{==, !=\}, they are also another rules for this equality checking.
We were trying to summarize the common parts of these rules, and only change as few as possible when we deal with different cases.
This is why we split the conversion into two parts: \emph{primitiveConversion} and \emph{objectConversion}, and reuse them in \emph{assignConversion}, \emph{castConversion} and \emph{equalityCheck}.


\section{Static Analysis}
%justin
% not sure how justin did it, this is assuming the attribute grammar is used

\subsection{Attribute Recursion Rules}
\subsection{Handling Base Cases}


\section{Challenges}
Last but not least, we would like to cover some technicalities involving the following challenges. Each further demonstrates how we model the solution, and how we engineer solution taking into account the characteritics of pure functional language.

\subsection{Type  Queries}
%siwei
We have briefly talked about the structure and primitive operations supported by the type database. However, it takes more than a tree traversal to find the correct type of each "name", simple or qualified.

\subsection{Instance Queries}
%siwei
Instance query is somewhat similar to the type query, except the traversal of type database can go back and forth multiple times.

\subsection{Hierarchy Queries}
%justin

\subsection{Forward-references Detection}
%siwei
Catching forward-reference should be trivial where detecting usage of unavailable variable names suffices. However, to maximize code reuse, our first attempt is to try hacking the symbol table where unavailable variables are moved out of the symbol so that processing of the initialization expression can go on without modification. Unfortunately, this solution fails to work on local variable declararions where hacking the local symbol table is not enough since the same name can appear at higher level. So we went with the detection solution in the end.
\begin{lstlisting}
Field varsym (Just expr) ->
  let syms = dropWhile (varsym /=) [sym | sym@(SYM mds _ _ _) <- sti, not $ elem "static" mds]
    forward = or (map (\sym -> identifierInExpr (localName sym) expr) syms)
  in if forward
      then typeLinkingFailure $ "forward use of syms " ++ (show varsym) ++ (show expr)
      else if typeLinkingExpr db imps su (Binary "=" (ID (Name ([localName varsym])) 0) expr 0) == [] then typeLinkingFailure $ "field type mis match expression " ++ (show varsym) ++ (show expr) else cts'
\end{lstlisting}

\subsection{Autoboxing and unboxing}

Joos supports autoboxing from a primitive type to a corresponding reference type, for example, primitive type \emph{int} can automatically convert to \emph{Object Integer} which is predefined in Java standard library.
Also we can do unboxing with some specific predefine reference types, then get a primitive type.
So we implemented functions \emph{boxingType} and \emph{unboxingType} so that we can support autoboxing and unboxing features.
However, \emph{String} is a special case here, because Java does not define a primitive type for literal string.
It means every literal string can be thought with type \emph{Object String}.
So we remove our predefine primitive type \emph{TypeString} for literal string from AST, and replace every \emph{TypeString} with type \emph{Object (Name ["java", "lang", "String"])}(need a canonical name here).

\section{Debugging and Testing Strategies}
%siwei

\end{document}


