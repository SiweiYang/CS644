\documentclass[12pt,letterpaper]{article}
\usepackage[margin=0.75in]{geometry}
\usepackage[pdftex]{graphicx}
\usepackage[parfill]{parskip}
\usepackage{listings}
\usepackage{color}
\lstset{language=Haskell, frame=single, breaklines=true, keywordstyle=\color{blue}, identifierstyle=\color{red}, basicstyle=\small}

% Submit to Marmoset a PDF document of no more than five pages explaining the design of this phase of your compiler.
% The document should be organized to enable someone unfamiliar with your code to understand the structure of (this phase of) your compiler.
% In the document, discuss challenges that you encountered and how you tried to overcome them in your design and implementation.
% Also explain the testing that you did before submitting to Marmoset.

\begin{document}

\begin{titlepage}
\begin{center}

% Title
\Large \textbf { {\bf CS644 Project} \\ Report: A4}\\[0.5in]

       \small \emph{Submitted in partial fulfillment of\\
        the requirements for the course}
        \vspace{.2in}

% Submitted by
\normalsize Submitted by \\
\begin{table}[h]
\centering
\begin{tabular}{lr}\hline \\
Name & ID\\ \\ \hline
\\
Siwei Yang & s8yang \\ \\ \hline
\\
Justin Vanderheide & jtvander \\ \\ \hline
\\
Jian Li & j493li \\ \\ \hline
\end{tabular}
\end{table}

\vfill

% Bottom of the page
\includegraphics[width=0.3\textwidth]{../res/UWLogo}\\[1.1in]
\Large{Department of Computer Science}\\
\normalsize
\textsc{University of Waterloo}\\
Waterloo, Ontario, Canada -- N2L 3G1 \\
\vspace{0.2cm}
Winter 2015

\end{center}
\end{titlepage}

\section{General Strategy}
%siwei
This section describes the meta strategy we applied in developing solutions to each of the deliverables. In principle, we are using the attribute grammar approach to finish all the tasks: name resolution, type linking and static analysis.

However, it takes more than merely coding the attribute rules to solve the problem. Auxiliary information might be needed at every node to make the right decision. And the information flows both ways which is hard to support is a pure functional language like Haskell. Besides, we would like to achieve a nice separation between the supporting data structures and the grammar structures.

Therefore, we modeled our solution as three parts: a transformed data structure captures the essence of the AST as well as supporting bi-directional information flow, a newly build data structure that answers queries from the attribute rules and the implementations of the attribute grammars.

\subsection{Engineering a Pure Functional Double-linked AST}

\subsection{Consolidating Type Hierarchy into a Database}

\subsection{Coding Attribute Rules}



\section{Name Resolution and Type Linking}
%jian

The name resolution part is implemented in the files \emph{Environment.hs} and \emph{TypeDatabase.hs}.

\subsection{Building Environments}
First, we tried to build environments from ASTs for all source files.
We traverse the AST from top to bottom, meanwhile we build environment using the information in AST nodes.
The structure of the environment is basically a recursive tree.
For each of tree node, it has a \emph{SemanticUnit} which capsules scope info, AST, symbol table and the parent pointer.
The configuration of symbol table is a linked list(or a list) corresponding to the path from the current tree node to the root, and every element in the symbol table is a structure \emph{Symbol}.
The \emph{Symbol} can represent either Package, Class, Interface, Function or Variable, and include all AST information we need.

\begin{lstlisting}
data Environment = ENVE
                 | ENV {
                    semantic :: SemanticUnit,
                    children :: [Environment]
                 } deriving (Eq)

data SemanticUnit = Root { scope :: [String] }
                  | SU {
                        scope :: [String],
                        kind :: Kind,
                        symbolTable :: [Symbol],
                        inheritFrom :: SemanticUnit
                  } deriving (Eq)
\end{lstlisting}

%\subsection{Constructing Type Database}

%To resolve the hierarchy between classes, interfaces and packages, we really need a database containing all package, inheritance and implementation relations, so that we can easily get the \emph{Symbol} by the name when we are doing name resolution.


\subsection{Type Linking}

Before we move on to this stage, we already got the symbol table and type database which can be used for looking up local variables and classes(interfaces as well) respectively.
However, the Joos language supports both single-type-import and import-on-demand.
So we can directly use the names of classes which are not in the same package.
This feature would cause lots of troubles during name resolution.
Our solution is first looking up the name from symbol table, if we can find a binding for this name, we return the type declared for this variable.
Otherwise, it is not in the symbol table, then we look up our type database to check whether it is a name of class or interface.
If we cannot find in the type database either, then we claim that we cannot resolve this name.

%\subsection{Reconstructing Environments with canonical names}


\subsection{Type Checking}

The assignment 2 only needs to do type linking which is a part of name resolution. However, when we were doing that part, we already got entire environment and type database.
So we could evaluate the type of each expression and return a list of possible types for that expression.
This is a recursive process since the type attribute of expression are synthesized.
Each time, we pass the current node environment to children, evaluate the types of subexpressions(children), and then combine all types of subexpressions with the format of current expression to get the type of this expression. 
If the return of an expression is an empty list, then we know there exists an error when we evaluated a subexpression or this expression, then just pass this empty list to the upper caller, i.e. propagating the error info to the root.
Or if the return has multiple types, there must exist some ambiguous name, in this case, we also need to report such error.

\subsection{Type Conversion}

Another issue need to deal with is type conversion.
We have to relax some strict type equality checking to a more complicated casting type system defined by conversion rules, since Joos language supports explicit type casting and implicit type conversion in some kinds of expressions.
This part is mainly implemented in the file \emph{TypeChecking.hs}.
According to JLS, there are many kinds of conversions for primitive types and references types.
And the conversions used in assignment(operator \{=\}) and casting are also slightly different.
Besides, for the binary operators \{==, !=\}, they are also another rules for this equality checking.
We were trying to summarize the common parts of these rules, and only change as few as possible when we deal with different cases.
This is why we split the conversion into two parts: \emph{primitiveConversion} and \emph{objectConversion}, and reuse them in \emph{assignConversion}, \emph{castConversion} and \emph{equalityCheck}.



%\subsection{Division of Responsibility}
%The scanner is implemented in the file \emph{Scanner.hs}.

%Each token type has an associated function that implements a recognizer for it. For example \emph{scanChar} recognizes char literals, and \emph{scanBool} recognizes boolean literals. Each of these functions consumes a string containing the unscanned portion of the file, and returns a Maybe representing the result.

%If the recognizer did not find its token type, it returns Nothing. For example if the input is "while (..." then \emph{scanDecimalInteger} will return Nothing since the beginning of the input is not a valid integer literal token. If the recognizer does find its token type then it returns a pair where the first element is the token type, and the second element is the lexeme of the token. For example in the input "while (..." the \emph{scanKeyword} function will return ("KEYWORD", "while"). Each of these functions is run in parallel, and the longest lexeme is taken.
%\begin{lstlisting}
%*Scanner> scanDecimalInteger "while ("
%Nothing
%*Scanner> scanKeyword "while ("
%Just ("KEYWORD","while")
%\end{lstlisting}

%\subsection{Attribute Recursion Rules}
%\subsection{Handling Base Cases}

\section{Static Analysis}
%justin
% not sure how justin did it, this is assuming the attribute grammar is used

\subsection{Attribute Recursion Rules}
\subsection{Handling Base Cases}


\section{Challenges}
\subsection{Type Queries}
%siwei
\subsection{Hierarchy Queries}
%justin
\subsection{Forward-references Detection}
%siwei
\subsection{Name resolution}

\subsection{Autoboxing and unboxing}

Joos supports autoboxing from a primitive type to a corresponding reference type, for example, primitive type \emph{int} can automatically convert to \emph{Object Integer} which is predefined in Java standard library.
Also we can do unboxing with some specific predefine reference types, then get a primitive type.
So we implemented functions \emph{boxingType} and \emph{unboxingType} so that we can support autoboxing and unboxing features.
However, \emph{String} is a special case here, because Java does not define a primitive type for literal string.
It means every literal string can be thought with type \emph{Object String}.
So we remove our predefine primitive type \emph{TypeString} for literal string from AST, and replace every \emph{TypeString} with type \emph{Object (Name ["java", "lang", "String"])}(need a canonical name here).

%siwei
\section{Debugging and Testing Strategies}
%siwei
\end{document}


